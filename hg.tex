\section{Formally Verified Disassembly}

\subsection{Example}

\begin{frame}[fragile]{Full Example}{A \emph{Hoare Graph}}
  \begin{columns}
    \column{.48\textwidth}
    \begin{block}{32-bit \gls{x86} for display purposes}
      \begin{lstlisting}[style=x64,gobble=8,basicstyle=\small\ttfamily]
        0x0 : cmp eax,c3 |\label{hg-example-cmp}|
        0x5 : ja  1c     |\label{hg-example-ja}|
        0xb : mov eax,DWORD PTR [eax*4+a]|\label{hg-example-jump-table-read}|
        0x12: mov DWORD PTR [edi],eax |\label{hg-example-mov1}|
        0x14: mov DWORD PTR [esi],1   |\label{hg-example-mov2}|
        0x1a: jmp DWORD PTR [edi]     |\label{hg-example-indirect-jump}|
      \end{lstlisting}
    \end{block}

    \column{.52\textwidth}
    % combination insser sep/minimum size ensures all nodes have exactly same size
    \tikzset{vertex/.style = {circle,draw,minimum size=0.2cm}} % inner sep=0pt, <- what does this even do?
    \begin{tikzpicture}[font=\tiny] % if time permits play around with setting -> here
      \node[vertex]    (0)     at  (0,0)  {$\mathtt{0}$};
      \node[vertex]    (5)     at  (1.5,0)  {$\mathtt{5}$};
      \node[vertex]    (1c)    at  (3,.25) {$\mathtt{1c}$};
      \node[draw=none] (1cret) at  (6,.25)  {};
      \node[vertex]    (b)     at  (3,-.25)  {$\mathtt{b}$};
      \node[draw=none] (120)   at  (1.6,-.75)  {};
      \node[draw=none] (121)   at  (2.3,-.75)  {};
      \node[vertex]    (122)   at  (3,-1)  {$\mathtt{12}$};
      \node[draw=none] (123)   at  (4,-.75)  {};
      \node[draw=none] (124)   at  (5,-.75)  {};
      \node[vertex]    (14)    at  (3,-1.75)  {$\mathtt{14}$};
      \node[vertex]    (1a2)   at  (3.5,-2.375)  {$\mathtt{1a}$};
      \node[vertex]    (ptr)   at  (3.5,-3)  {$a_\mathtt{jt}$};
      \node[draw=none] (ptret) at  (5,-3)  {};
      \node[vertex]    (1a1)   at  (2.5,-2.375)  {$\mathtt{1a}$};
      \node[vertex]    (1)     at  (2.5,-3)  {$\mathtt{1}$};
      \node[vertex]    (ret)   at  (1,-3)  {$a_\mathtt{r}$};

      % right tells tikz to start drawing the node right of the position (instead of centered)
      \node[right,text width=3.87cm,align=left] at (-2,.75) {\begin{align*}
          P_0 &= \readmem{\reg{rsp}} == a_\mathtt{r}\\
          M_0 &= \emptyset
      \end{align*}};

      \node[right] at (3.4,-.2) {$
        \reg{eax} < \mathtt{0xc3}
        $};

      \node[right] at (3.4,-1) {$
        \reg{eax} == a_\mathtt{jt}
        $};

%      \node[right] at (3.4,-1.5) {$
%        \readmem{\reg{edi}}4 == a_\mathtt{jt}
%        $};
%
%      \node[right] at (3.8,-2.25) {$
%        \begin{array}{c}
%          \region{\reg{edi}}4 \gls{separate} \region{\reg{esi}}4 \\
%          \readmem{\reg{edi}}4 == a_\mathtt{jt}
%        \end{array}
%        $};
%
%      \node[left] at (2.15,-2.25) {$
%        \begin{array}{c}
%          [\reg{edi},4] \equiv [\reg{esi},4] \\
%          *[\reg{edi},4] == 1
%        \end{array}
%        $};
%
%      \draw [overlay,decorate,decoration={brace,amplitude=10pt,mirror},xshift=-4pt] (6,-.75) -- (6,-.25) node [black,midway,xshift=1.4cm] {
%        \begin{tabular}{l}
%          up to $\mathtt{0xc3}$\\
%          edges: one\\
%          per read\\
%          value
%        \end{tabular}
%      };

      \path[->] (0) edge node [above] {\inlineasm{cmp}} (5);
      \path[->] (5) edge node [above] {\inlineasm{ja}} (1c);
      \path[->] (5) edge node [below] {\inlineasm{ja}} (b);
      \draw[dotted,->] (1c) edge node [above] {$\reg{eax} \geq \mathtt{0xc3}$} (1cret);
      \draw[dotted,->] (b)   to (120);
      \draw[dotted,->] (b)   to (121);
      \draw[->]        (b)   to (122);
      \draw[dotted,->] (b)   to (123);
      \path[dotted,->] (b)   edge node [right,xshift=0.2] {\inlineasm{mov}} (124);
      \path[->]        (122) edge node [right] {\inlineasm{mov}} (14);
      \path[->]        (1a2) edge node [right] {\inlineasm{jmp}} (ptr);
      \draw[dotted,->] (ptr) to (ptret);
      \path[->]        (14)  edge node [left]  {\inlineasm{mov}} (1a1);
      \path[->]        (14)  edge node [right] {\inlineasm{mov}} (1a2);
      \path[line width=2pt,->] (1a1) edge node [left] {\inlineasm{jmp}} (1);
      \path[line width=2pt,->] (1) edge node [below] {{\textbf{\inlineasm{ret}}}} (ret);
    \end{tikzpicture}
  \end{columns}
\end{frame}

\begin{frame}{State of the Art}
  \begin{block}{Jakstab}
    \begin{outline}
      \1 Uses \alert{abstract interpretation}
      \1 Requires significant \alert{test harnesses}
      \1 Does not achieve full \alert{overapproximation}
    \end{outline}
  \end{block}
\end{frame}

\subsection{Formulation}

%\begin{frame}{Basics of State}
%  \begin{columns}
%    \column{.35\textwidth}
%    \begin{block}{Main Parts}
%      \begin{outline}[enumerate]
%        \1 \alert{Predicates} on state
%        \1 Structured \alert{memory models}
%      \end{outline}
%    \end{block}
%
%    \column{.65\textwidth}
%    \todo{some filler figure here to look nice}
%  \end{columns}
%\end{frame}
%
%\begin{frame}{State Predicates}
%  \begin{columns}
%    \column{.45\textwidth}
%    \begin{block}{Predicate Breakdown}
%      \begin{outline}
%        \1 Set of \alert{clauses}
%        \1 Clauses model values of individual \alert{state parts}
%        \1 Only holds on state if all clauses hold
%        \1 Also indicates next instruction to evaluate!
%      \end{outline}
%    \end{block}
%
%    \column{.55\textwidth}
%    \begin{example}[Predicate]
%      \todo{taking from dissertation}
%    \end{example}
%  \end{columns}
%\end{frame}
%
%\begin{frame}{Memory Models}
%  \begin{columns}
%    \column{.425\textwidth}
%    \begin{block}{What are they?}
%      \begin{outline}
%        \1 \alert{Forest} structure of \alert{memory regions}
%        \1 Different arrangements for different possible \alert{relations}
%          \2 \alert{Aliasing}
%          \2 \alert{Separation}
%          \2 \alert{Enclosure}
%        \1 Only holds if state matches
%      \end{outline}
%    \end{block}
%
%    \column{.575\textwidth}
%    \begin{example}[Memory Model]
%      \todo{taking from dissertation}
%    \end{example}
%  \end{columns}
%\end{frame}
%
%\begin{frame}{Nondeterminism}
%  \begin{columns}
%    \column{.4\textwidth}
%    \begin{block}{Why?}
%      \begin{outline}
%        \1 Most aliasing is \alert{potential}
%        \1 Want to model all possibilities
%        \1 Also want to model control flow!
%      \end{outline}
%    \end{block}
%
%    \column{.6\textwidth}
%    \begin{example}[Nondeterminism]
%      \todo{taking from dissertation}
%    \end{example}
%  \end{columns}
%\end{frame}

\begin{frame}{Base Algorithm}
  \begin{outline}[enumerate]
    \1<+-> Pop state off \gls{bag} of states to analyze
    \1<+-> If state \alert{``less than''} existing state in \gls{hg}, join and update \gls{hg}
    \1<+-> Evaluate current instruction in potentially-joined state; may result in multiple result states
    \1<+-> Can continue? For each result:
      \2 If yes, add to bag
      \2 If no, annotate in \gls{hg}
  \end{outline}
\end{frame}

\begin{frame}{Extension for Function Calls}
%  \begin{columns}
%    \column{.55\textwidth}
    \begin{block}{State Modifications}
      \begin{outline}
        \1<+-> External calls preserve only stack, \alert{caller-saved} registers
        \1<+-> Internal calls
          \2 Preserve stack, \alert{caller-saved} registers at call site
          \2 State within call reset, allowing reuse of results
          \2 Perform join of state-within-call and post-call state for subcall return
        \1<+-> Requires concept of \alert{reachability}; post-call states not continued unless known reachable
      \end{outline}
    \end{block}
%
%    \column{.45\textwidth}
%    \begin{example}[Function Call]
%      \todo{taking from dissertation}
%    \end{example}
%  \end{columns}
\end{frame}

% Leaving out validation as that was Freek's work. I'll answer questions if it gets brought up but dedicating time to it explicitly is probably not worth it.

\subsection{Results}

\begin{frame}{Case Study: Xen Project}
  \begin{columns}
    \column{.35\textwidth}
    \colorbox{black}{\includegraphics[width=\linewidth-2\fboxsep]{logo_xenproject}}

    \column{.6\textwidth}
    \begin{block}{Properties}
      \begin{outline}
        \1 Widely used \gls{vmm}/hypervisor
        \1 Mostly written in \gls{c}
      \end{outline}
    \end{block}
  \end{columns}
\end{frame}

% Fragile was needed with the newcolumn being inside the frame but moving it out fixed that
\begin{frame}[label=hg-results]{Statistics Summarized}
  \centering
  \begin{tabular}{l
      S[table-format=4]@{$=$}
      S[table-format=4]@{$+$}
      S[table-format=2]@{$+$}
      S[table-format=2]@{$+$}
      S[table-format=1]
      S[table-format=6]
      S[table-format=6]
      S[table-format=2]
      S[table-format=3]
      S[table-format=3]
      r}
    \toprule
    \thead{Binary Target Type} & {\thead{Total}} & {\thead{$w$}} & {\thead{$x$}} & {\thead{$y$}} & {\thead{$z$}} & {\thead{Instrs.}} & {\thead{Symbolic\\States}} & {\thead{A}} & {\thead{B}} & {\thead{C}} & \thead{Time/\\h:m:s} \\
    \midrule
    Programs &  \glsentrysymbol{bin-total} & \glsentrysymbol{bin-success} & 3 & 13 & 1 & 18124 & 18562 & 56 & 26 & 11 & 0:35:59 \\
    Library Functions & \glsentrysymbol{lib-func-total} & \glsentrysymbol{lib-func-success} & 32 & 0 &  \glsentrysymbol{lib-func-timeout} & 381647 & 391524 & 1 & 244 & 720 & 17:35:42 \\
    \bottomrule
  \end{tabular}\\
  \begin{tabular}{rcl rcl rcl}
    \multicolumn{9}{c}{$w$ lifted, $x$ unprovable return address, $y$ concurrency, $z$ timeout} \\
    A &=& Resolved indirection & B &=& Unresolved jump(s) & C &=& Unresolved call(s) \\
  \end{tabular}
  \hyperlink{timing}{\beamerskipbutton{Timing}}
\end{frame}

\begin{frame}{Discussion and Limitations}
  \begin{outline}
    \1 Implemented in \gls{c}, so only \gls{c} exception handling
    \1 But what if it used \gls{cpp} exception handling?
  \end{outline}
\end{frame}
