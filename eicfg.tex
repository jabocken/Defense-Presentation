\begin{frame}{Breakdown of Contributions}
  \begin{outline}[enumerate] % Don't think this environment works with <+-> directly
    \1<+-> \alert{Formal abstract model} of \glsxtrfull{eh} \glsxtrfull{abi} functions
    \1<+-> \alert{Algorithm} using model for \glsxtrfull{cfr}
    \1<+-> \alert{Validation} of the model
    \1<+-> \alert{Evaluation} showing scalability and increased coverage
  \end{outline}
\end{frame}

\section{Formulation}
\begin{frame}{Basics of State}
  \begin{outline}
    \1 Focused on \alert{exceptional state} and \alert{function calls}
    \1 Requires static components from binary such as the \alert{landing pad table ($\landingpadtable$)}
    \2 Encodes unwinding destinations for ranges of addresses
    \1 Leaves out parts that can be overapproximated
    \2 Produced stack only contains return addresses!
  \end{outline}
\end{frame}

\begin{frame}{Generation}{What's the special sauce?}
  \begin{outline}[enumerate]
    \1<+-> Extract $\landingpadtable$ from binary
    \1<+-> \alert{Symbolically execute} the binary
    \2<+-> Start from \glsxtrfull{ip} with initial \alert{symbolic state}
    \2<+-> Dissassemble instruction at that \gls{ip}
    \2<+-> Transform current state (including \gls{ip}) based on semantics of instruction (adds edge(s) to \gls{eicfg})
    \2<+-> Repeat with resulting state(s) until termination conditions encountered
    \1<+-> \alert{During 2.3, when encountering exceptional \gls{abi} calls, model them!}
  \end{outline}
\end{frame}

\begin{frame}{Modeling Exceptional \Glsxtrshort{abi} Calls}{Specification source: \citeurl{cxxEhAbi}}
  \begin{block}{\inlineasm{__cxa_throw}}
    \begin{outline}[enumerate]
      \1<+-> If current \gls{ip} is in $\landingpadtable$:
      \2<+-> Jump to target and stop unwinding
      \2<+-> Add corresponding edge to \gls{eicfg}
      \1<+-> Otherwise, unwind:
      \2<+-> Pop off current function call stack frame
      \2<+-> Jump to that frame's stored return address
      \2<+-> Add corresponding edge to \gls{eicfg}
      \1<+-> Repeat until no more stack frames are available, then terminate (\alert{unhandled exception})
    \end{outline}
  \end{block}
\end{frame}

\section{Validation}
\begin{frame}{How to check abstract semantics versus concrete?}
  \centering
  Compare to \alert<+>{real-world} executions of the functions being modeled!
  \vfill
  \begin{equation}
    \alert<+>{\sigma\absTransition\sigma'}
    \land
    \alert<+>{\gamma(\sigma)\concTransition s'}
    \implies
    \alert<+>{\alpha(s')=\sigma'}
    \label{eq:validation}
  \end{equation}
  \vfill
  \uncover<+>{Requires real-world \alert{crafted programs} for the functions though\dots}
\end{frame}

\begin{frame}{Process}
  \begin{outline}[enumerate]
    \1<+-> \alert{Fuzz} the \alert{abstract} states to get set of \alert{inputs} (we generated \glssymbol{fuzz-count})
    \1<+-> Execute abstract function models to get abstract \alert{outputs}
    \1<+-> \alert{Concretize}, inject abstract inputs into crafted programs using \alert{test harness} (\gls{gdb} used to set breakpoints, overwrite and view concrete program state)
    \1<+-> Check \alert{abstracted} \alert{concrete} outputs against abstract outputs for corresponding inputs
  \end{outline}
\end{frame}

\begin{frame}{Results}{Basic Summary}
  \begin{columns}
    \column{.45\textwidth}
    \begin{block}{Functions covered}
      \begin{outline}
        \1 \inlineasm{__cxa_throw}
        \1 \inlineasm{__cxa_begin_catch}
        \1 \inlineasm{__cxa_end_catch}
        \1 \inlineasm{__cxa_rethrow}
        \1 \inlineasm{_Unwind_Resume}
      \end{outline}
    \end{block}
    \pause
    \column{.45\textwidth}
    \begin{block}{State parts validated}
      \begin{outline}
        \1 in/out registers
        \1 type of current exception
        \1 exception handler count
        \1 count of uncaught exceptions
        \1 partial stack of caught exceptions
      \end{outline}
    \end{block}
  \end{columns}
\end{frame}

\begin{frame}{Results}{Some Discoveries}
  \begin{outline}
    \1 Concrete implementation of \inlineasm{__cxa_begin_catch} takes absolute value of negative handler counts supplied to it before incrementing that value
    \1 \inlineasm{__cxa_rethrow} decreases $\handlerCount$ magnitude by one, then inverts sign; if the magnitude is 0, it is unchanged
  \end{outline}
\end{frame}

\section{Evaluation}
\begin{frame}{Case Studies}
  \begin{outline}
    \1<+-> Tested \glssymbol{total-bins} programs from a variety of sources
    \2 Publicly available \glsxtrshort{nasa} tools
    \2 Programs and libraries from \gls{xen} hypervisor
    \2 Various printing-related and document type conversion tools available on Linux
    \2 Miscellaneous other programs
    \1<+-> Combination of \gls{c}, \gls{cpp}, even \gls{fortran}
    \1<+-> Special handling:
    \2<+-> Treated all function symbol addresses in binaries as potential starting \glspl{ip}
    \2<+-> Did two runs, one with \gls{eh} support, one without; compared results
  \end{outline}
\end{frame}

\begin{frame}{Statistics Summarized}
  \centering
  \begin{tabular}{l
      r% S[table-format=3]
      S[table-format=4] % total inst count
%      S[table-format=6]
%      S[table-format=4]
%      S[table-format=4]
%      S[table-format=1.2]
%      S[table-format=2] % average memory usage in gigabytes
      |
      S[table-format=5] % inst coverage differential
    }
    \toprule
%           & \multicolumn{7}{c}{\thead{Absolute Numbers}} & {\thead{Baseline\\Comparison}} \\
           & \multicolumn{2}{c}{\thead{Absolute Numbers}} & {\thead{Baseline\\Comparison}} \\
    \midrule
%           & {\thead{Bin Count}}                          & {\thead{Covered\\Insts (\si{K})}} & {\thead{Unwind\\Edges}} & {\thead{Unique\\Throws}} & {\thead{Caught\\Throws}} & {\thead{Time\\(\si\hour)}} & {\thead{Avg.\\Mem\\(\si{\gibi\byte})}} & {\thead{Inst Diff}} \\
           & {\thead{Binary Count}}                          & {\thead{Covered Insts (\si{K})}} & {\thead{Instruction Differential}} \\
    \midrule
%    Totals & \glssymbol{eicfg-bin-success}/341            & 4089                            & 484274                  & 2574                     & 1814                     & 5.96                       & 30                                     & 36200 \\
           Totals & \glssymbol{eicfg-bin-success}/341            & 4089                     & 36200 \\
    \bottomrule
  \end{tabular}
\end{frame}

\begin{frame}{Ending Discussion}
  \begin{columns}
    \column{.54\textwidth}
    \begin{block}{Limitations}
      \begin{outline}
        \1 No concurrency support
        \2 Thread-spawning functions treated as single-threaded
        \1 Even here not all indirections are resolvable
        \2 Contextuality versus scalability
        \2 How to deal with that?
      \end{outline}
    \end{block}
    \pause
    \column{.36\textwidth}
    \begin{block}{Uses and Future Work}
      \begin{outline}
        \1 Strengthening static analyses
        \2 Developed as a library for easy integration
        \1 Improving decompilation
        \2 Ghidra plugin?
      \end{outline}
    \end{block}
  \end{columns}
\end{frame}
